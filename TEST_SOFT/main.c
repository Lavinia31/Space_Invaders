    /*****
        Project : Test software
        ******
        Chip type: ATmega164A
        Clock frequency: 20 MHz
        Compilers:  CVAVR 2.x
        *****/

        #include <mega164a.h>

        #include <stdio.h>
        #include <delay.h>  
        #include <string.h> 
        #include <stdlib.h>
        #include "defs.h"    
        #include <stddef.h> 
        #include <alcd.h>

       
        #asm
        .equ __lcd_port = 0x15 ;PORTC
        #endasm
         
      // #include <lcd.h>

        //***********
        //** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) ****
        //***********

        #ifndef RXB8
        #define RXB8 1
        #endif

        #ifndef TXB8
        #define TXB8 0
        #endif

        #ifndef UPE
        #define UPE 2
        #endif

        #ifndef DOR
        #define DOR 3
        #endif

        #ifndef FE
        #define FE 4
        #endif

        #ifndef UDRE
        #define UDRE 5
        #endif

        #ifndef RXC
        #define RXC 7
        #endif

        #define FRAMING_ERROR (1<<FE)
        #define PARITY_ERROR (1<<UPE)
        #define DATA_OVERRUN (1<<DOR)
        #define DATA_REGISTER_EMPTY (1<<UDRE)
        #define RX_COMPLETE (1<<RXC)
        
         
        
        // USART0 Receiver buffer
        #define RX_BUFFER_SIZE0 8
        char rx_buffer0[RX_BUFFER_SIZE0];
        
        #if RX_BUFFER_SIZE0 <= 256
        unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;
        #else
        unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
        #endif

        // This flag is set on USART0 Receiver buffer overflow
        bit rx_buffer_overflow0;

        // USART0 Receiver interrupt service routine
        interrupt [USART0_RXC] void usart0_rx_isr(void)
        {
        char status,data;
        status=UCSR0A;
        data=UDR0;
        if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
           {
           rx_buffer0[rx_wr_index0++]=data;
        #if RX_BUFFER_SIZE0 == 256
           // special case for receiver buffer size=256
           if (++rx_counter0 == 0) rx_buffer_overflow0=1;
        #else
           if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
           if (++rx_counter0 == RX_BUFFER_SIZE0)
              {
              rx_counter0=0;
              rx_buffer_overflow0=1;
              }
        #endif
           }
        }

        #ifndef DEBUG_TERMINAL_IO
        // Get a character from the USART0 Receiver buffer
        #define ALTERNATE_GETCHAR
        #pragma used+
        char getchar(void)
        {
        char data;
        while (rx_counter0==0);
        data=rx_buffer0[rx_rd_index0++];
        #if RX_BUFFER_SIZE0 != 256
        if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
        #endif
        #asm("cli")
        --rx_counter0;
        #asm("sei")
        return data;
        }
        #pragma used-
        #endif

        // USART0 Transmitter buffer
        #define TX_BUFFER_SIZE0 8
        char tx_buffer0[TX_BUFFER_SIZE0];

        #if TX_BUFFER_SIZE0 <= 256
        unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
        #else
        unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
        #endif

        // USART0 Transmitter interrupt service routine
        interrupt [USART0_TXC] void usart0_tx_isr(void)
        {
        if (tx_counter0)
           {
           --tx_counter0;
           UDR0=tx_buffer0[tx_rd_index0++];
        #if TX_BUFFER_SIZE0 != 256
           if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
        #endif
           }
        }

        #ifndef DEBUG_TERMINAL_IO
        // Write a character to the USART0 Transmitter buffer
        #define ALTERNATE_PUTCHAR
        #pragma used+
        void putchar(char c)
        {
        while (tx_counter0 == TX_BUFFER_SIZE0);
        #asm("cli")
        if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
           {
           tx_buffer0[tx_wr_index0++]=c;
        #if TX_BUFFER_SIZE0 != 256
           if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
        #endif
           ++tx_counter0;
           }
        else
           UDR0=c;
        #asm("sei")
        }
        #pragma used-
        #endif
        //***********
        //**END SERIAL STUFF (USART0)  ******
        //***********
        //*   if you need USART1, enable it in Code Wizard and copy coresponding code here  *
        //***********

        /*
         * Timer 1 Output Compare A interrupt is used to blink LED
         */
        interrupt [TIM1_COMPA] void timer1_compa_isr(void)
        {
        //LED1 = ~LED1; // invert LED    
        }                                  


        typedef unsigned char byte;
        flash byte char0[10] = {
        0b10000,
        0b10000,
        0b10000,
        0b10000,
        0b10000,
        0b10000,
        0b11111,
        0b00000,
        0b00000,
        0b00000
        };
        flash byte racheta[10] = {
        0b00100,
        0b00100,
        0b00100,
        0b10101,
        0b01110,
        0b11111,
        0b00000,
        0b00000,
        0b00000,
        0b00000
        };
        flash byte monstru[10] = {
        0b10101,
        0b01110,
        0b11111,
        0b00100,
        0b11111,
        0b00100,
        0b00100,
        0b00100,
        0b00000,
        0b00000
        };
        flash byte clear[10] = {
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000
        };
        flash byte b0[10] = {
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00100
        };
        flash byte b1[10] = {
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00100,
        0b00100
        }; 
        flash byte b2[10] = {
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00100,
        0b00100,
        0b00000
        };   
        flash byte b3[10] = {
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00100,
        0b00100,
        0b00000,
        0b00000
        };
        flash byte b4[10] = {
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00100,
        0b00100,
        0b00000,
        0b00000,
        0b00000
        }; 
        flash byte b5[10] = {
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00100,
        0b00100,
        0b00000,
        0b00000,
        0b00000,
        0b00000
        };   
        flash byte b6[10] = {
        0b00000,
        0b00000,
        0b00000,
        0b00100,
        0b00100,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000
        };
        flash byte b7[10] = {
        0b00000,
        0b00000,
        0b00100,
        0b00100,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000
        };   
        flash byte b8[10] = {
        0b00000,
        0b00100,
        0b00100,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000
        };
        flash byte b9[10] = {
        0b00100,
        0b00100,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000
        }; 
        flash byte b10[10] = {
        0b00100,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000,
        0b00000
        };   
        
        void define_char(byte flash *pc, byte char_code)
        {
        byte i, a;
        a = (char_code<<3) | 0x40;
        for(i=0;i<10;i++) lcd_write_byte(a++, *pc++);
        }

        void right(int c){
            if(c<31){
                define_char(racheta,1);
                lcd_gotoxy(c+1,1);
                lcd_putchar(1);
                define_char(clear,2);
                lcd_gotoxy(c,1);
                lcd_putchar(2); 
                delay_ms(150);
                
                }
        } 
        
        void left(int c){
            if(c>16){ 
                define_char(racheta,1);
                lcd_gotoxy(c-1,1);
                lcd_putchar(1);
                define_char(clear,2);
                lcd_gotoxy(c,1);
                lcd_putchar(2); 
                delay_ms(250);
                }
        }
          
        flash byte* vector[]={b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10};
        void afisare(int b,int c, int r, int idx, int v){
            if(v==2){
                define_char(vector[b],3);
                define_char(vector[11-b],4);
                lcd_gotoxy(c,r); 
                lcd_putchar(3);
                lcd_gotoxy(idx,r); 
                lcd_putchar(4);
                delay_ms(30);  
            }
            if(v==0){
                define_char(vector[b],3);
                lcd_gotoxy(c,r); 
                lcd_putchar(3);
                delay_ms(30);}
         }
         void cl(int c, int r){
            define_char(clear,2);
            lcd_gotoxy(c,r);
            lcd_putchar(2); 
            delay_ms(30);
         }
         void main (void)
        {   int col=23, rand=1;
            int k,j;
            int i=3; 
            int matr[2][16]={0};
            int nr=0;
            int index=16;
            int verif=0; 
            int nr1=1;
            int nr2=2;
            
                 
            LED1 = 0;  
            lcd_init(416);
            lcd_gotoxy(0,0);
            lcd_putsf("START GAME!");
            delay_ms(3000); 
            lcd_init(416);   
               for(j=0;j<2;j++) 
                    for(k=0;k<16;k++){
                        define_char(monstru,0);
                        lcd_gotoxy(k,j);
                        lcd_putchar(0);
                }
                
             define_char(racheta,1);
             lcd_gotoxy(col,rand);
             lcd_putchar(1);  
           while(1){
            if(RIGHT==0){
                right(col);
                col++;
            }
                
            if(LEFT==0){
                left(col); 
                col--;
            } 
            
            if(BULLET==0){
                if(matr[1][col-16]==0){
                    j=col;
                    if(index%4==0&&matr[1][index-16]==0)
                        verif=nr2;
                    else 
                        verif=0;
                    for (k = 0; k < 11; k++){  
                        afisare(k,j, 0,index, verif);
                        if(RIGHT==0){
                            right(col);
                            col++;
                        }
                
                        if(LEFT==0){
                            left(col); 
                            col--;
                        }
                    }
                    if(verif==2)
                        cl(index,0);
                   
                    cl(j,0);
                    matr[1][j-16]=2; 
                    nr++;
                    if(index==col&&verif==2){
                        lcd_init(416); 
                        lcd_clear();
                        lcd_gotoxy(0,0);
                        lcd_putsf("GAME OVER!");
                    }
                    else{ 
                        if(index%4==0&&verif==2){
                            cl(j-16,1);
                            for (k = 10; k >=0; k--)   
                                afisare(k,index, 1,index,0);
                            cl(index,1);
                            
                        }
                        else cl(j-16,1);
                        
                        
                    } 
                    
                if(index>=32)
                    index=16;
                else
                    index=index+2; }
              
              else
                       if(matr[1][col-16]==2&&matr[0][col-16]==0){
                            verif=0; 
                            j=col;
                            for (k = 0; k < 11; k++) {  
                                afisare(k,j, 0,index,verif);
                                if(RIGHT==0){
                                    right(col);
                                    col++;
                                }
                
                                if(LEFT==0){
                                    left(col); 
                                    col--;
                                }       
                            }
                            cl(j,0);

                            for (k = 0; k < 11; k++) {  
                                afisare(k,j-16, 1,index,verif);
                                if(RIGHT==0){
                                    right(col);
                                    col++;
                                }
                                    
                                if(LEFT==0){
                                    left(col); 
                                    col--;
                                }
                            }
                            
                            cl(j-16,1);
                            cl(j-16,0);
                            matr[0][j-16]=2;
                            nr++; 
                            
                            
                        }
                        else if(matr[0][col-16]==2){
                                verif=0;
                                j=col;
                                for (k = 0; k < 11; k++) {  
                                    afisare(k,j, 0,index, verif);
                                    if(RIGHT==0){
                                        right(col);
                                        col++;
                                    }
                                        
                                    if(LEFT==0){
                                        left(col); 
                                        col--;
                                    }
                                }
                                cl(j,0);
                                for (k = 0; k < 11; k++) {  
                                    afisare(k,j-16, 1, index, verif);
                                    if(RIGHT==0){
                                        right(col);
                                        col++;
                                    }
                                        
                                    if(LEFT==0){
                                        left(col); 
                                        col--;
                                    }
                                }
                                cl(j-16,1); 
                                for (k = 0; k < 11; k++) {  
                                    afisare(k,j-16, 0, index, verif);
                                    if(RIGHT==0){
                                        right(col);
                                        col++;
                                    }
                                        
                                    if(LEFT==0){
                                        left(col); 
                                        col--;
                                    }
                                }
                                cl(j-16,0);
                                       
                        } 
                  index=index+2;
                } 
                if(nr==32){
                    lcd_init(416); 
                    lcd_clear();
                    lcd_gotoxy(0,0);
                    lcd_putsf("Congratulations!YOU'RE THE BEST!");
                    }  
            }
            
            }